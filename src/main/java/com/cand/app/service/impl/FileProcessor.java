/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.cand.app.service.impl;

import com.cand.app.entity.Bank;
import com.cand.app.entity.Customer;
import com.cand.app.entity.UniqueTransaction;
import com.cand.app.exception.FileProcessFailException;
import com.cand.app.exception.Message;
import com.cand.app.json.JsonCustomer;
import com.cand.app.json.JsonTransaction;
import com.cand.app.service.ICustomerService;
import com.cand.app.service.ITransactionService;
import com.google.gson.Gson;
import org.jboss.logging.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import java.io.IOException;
import java.io.Reader;
import java.math.BigDecimal;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.function.Predicate;
import java.util.stream.Collectors;

@Component
public class FileProcessor {

    private static final Logger log = Logger.getLogger(FileProcessor.class);
    public static final String CUSTOMER_JSON = "customer.json";

//    static {
//        Customer c1 = new Customer("Jadzia Dax", new Bank("011000015", "6622085487"));
//        Customer c2 = new Customer("James T. Kirk", new Bank("021001208", "0018423486"));
//        Customer c3 = new Customer("Jean-Luc Picard", new Bank("021001208", "1691452698"));
//        Customer c4 = new Customer("Jonathan Archer", new Bank("011000015", "3572176408"));
//        Customer c5 = new Customer("Leonard McCoy", new Bank("011000015", "8149516692"));
//        Customer c6 = new Customer("Montgomery Scott", new Bank("011000015", "7438979785"));
//        Customer c7 = new Customer("Spock", new Bank("011000015", "1690537988"),
//                new Bank("021001208", "1690537989"));
//        Customer c8 = new Customer("Wesley Crusher", new Bank("011000015", "6018423486"));
//        customers.addAll(Arrays.asList(c1, c2, c3, c4, c5, c6, c7, c8));
//    }

    @Autowired
    ITransactionService transactionService;

    @Autowired
    ICustomerService customerService;

    private String getCustomerNameForTransaction(UniqueTransaction dao, List<Customer> customers) {
        Customer customer = customers.stream()
                .filter(e -> e.getAccounts().contains(new Bank(dao.getRoutingNumber(), dao.getAccountNumber(), e)))
                .findFirst().orElse(null);
        return customer != null ? customer.getFullName() : Customer.UNKNOWN;
    }

    private <T> T readFileAndPrepareObject(Path p, Class<T> glass) throws IOException {
        Reader reader = Files.newBufferedReader(p);
        return new Gson().fromJson(reader, glass);
    }

    private Set<UniqueTransaction> prepareBankTransactionFrom(Path p, List<Customer> customers) {
        JsonTransaction trans = null;
        try {
            trans = readFileAndPrepareObject(p, JsonTransaction.class);
        } catch (IOException e) {
            log.error("Failed to load files from given path : " + e.getLocalizedMessage());
            // Do not stop processing; continue!
        }
        Set<UniqueTransaction> transacDAO = trans.transactions.stream().map(e -> {
            UniqueTransaction transactionDAO = new UniqueTransaction();
            transactionDAO.populateDAO(e);
            transactionDAO.setCustomerName(getCustomerNameForTransaction(transactionDAO, customers));
            return transactionDAO;
        }).collect(Collectors.toSet());
        return transacDAO;
    }

    @PostConstruct
    private void init() {
        Path path = Paths.get("./data/");
        List<Path> allFiles = null;
        try {
            allFiles = Files.walk(path).filter(e -> Files.isRegularFile(e)).collect(Collectors.toList());
        } catch (IOException e) {
            log.error("Failed to load files from given path \n Continuing for now: " + e.getLocalizedMessage());
        }
        List<Customer> customers = setUpAndGetCustomers(allFiles);

        // There might be many files; better to load them in seperate thread and allow the application to become responsive.
        new Thread(new PopulateTransactionDB(customers, allFiles)).start();
    }

    private Predicate<Path> filterOnTransactionFiles() {
        return e -> !e.getFileName().startsWith(CUSTOMER_JSON);
    }

    private List<Customer> setUpAndGetCustomers(List<Path> path) {
        Path customerPath = path.stream().filter(e -> e.getFileName().startsWith(CUSTOMER_JSON))
                .findFirst().orElseThrow(() -> new FileProcessFailException(Message.CUSTOMER_FILE_NOT_FOUND));
        List<Customer> customers = null;
        try {
            customers = readFileAndPrepareObject(customerPath, JsonCustomer.class).customers;
        } catch (IOException e) {
            log.error("Failed to load customers file better to exist the processing!! : " + e.getLocalizedMessage());
            System.exit(0);
        }
        customers.forEach(c -> c.getAccounts().forEach(b -> b.setCustomer(c)));
        customerService.saveAll(new HashSet<>(customers));
        return customers;
    }

    private class PopulateTransactionDB implements Runnable {

        private List<Customer> customers;
        private List<Path> allFiles;

        public PopulateTransactionDB(List<Customer> customers, List<Path> allFiles) {
            this.customers = customers;
            this.allFiles = allFiles;
        }

        @Override
        public void run() {
            try {
//                Simulate reading huge number of files!!
                Thread.sleep(3000l);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            List<Path> transactionFiles = allFiles.stream().filter(filterOnTransactionFiles()).collect(Collectors.toList());
            for (Path p : transactionFiles) {
                Set<UniqueTransaction> transactions = prepareBankTransactionFrom(p, customers);
                try {
                    transactionService.saveAll(transactions); // Inserting in bulk each file
                } catch (RuntimeException e) {
                    log.error("Failed to parse and save records from file : " + p.getFileName());
                    // Continue, don't stop
                }
            }
            Set<UniqueTransaction> totalKnwonCustoemrs = new HashSet<>();
            for (Customer c : customers) {
                Set<UniqueTransaction> knownCustomerTrans = transactionService.getCustomerTransaction(c.getFullName());
                totalKnwonCustoemrs.addAll(knownCustomerTrans);
                BigDecimal sum = knownCustomerTrans.stream().map(e -> e.getAmount()).reduce(BigDecimal.valueOf(0), BigDecimal::add);
                System.out.println(String.format("Balance for %s: count=%d sum=%.2f USD", c.getFullName(),
                        knownCustomerTrans.size(), sum));
            }
            Set<UniqueTransaction> unknownCustomers = transactionService.getUnknownCustomerTransaction();
            BigDecimal unknownSum = unknownCustomers.stream().map(e -> e.getAmount()).reduce(BigDecimal.valueOf(0), BigDecimal::add);
            System.out.println("Balance without known user: count=" + unknownCustomers.size() + " sum=" + unknownSum + " USD");

            List<BigDecimal> known = totalKnwonCustoemrs.stream().map(e -> e.getAmount()).sorted().collect(Collectors.toList());
            System.out.println("Balance smallest valid: " + known.get(0) + " USD");
            System.out.println("Balance largest valid: " + known.get(known.size() - 1) + " USD");
        }
    }
}
